â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  BUá»”I 1: ARCHITECTURAL THINKING & TRADE-OFFS
  Há»‡ thá»‘ng: E-commerce Mini
  Sinh viÃªn: TÃ´n Phan Kim Tháº¡ch - 22637901
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## PHáº¦N 1: XÃC Äá»ŠNH 10 ARCHITECTURAL CHARACTERISTICS

Sau khi phÃ¢n tÃ­ch há»‡ thá»‘ng E-commerce mini (bao gá»“m: product catalog, shopping cart, 
payment, order management, user authentication), tÃ´i xÃ¡c Ä‘á»‹nh cÃ¡c Ä‘áº·c tÃ­nh kiáº¿n trÃºc:

1. **AVAILABILITY (TÃ­nh kháº£ dá»¥ng)** 
   - Há»‡ thá»‘ng pháº£i accessible 99.5% thá»i gian (cÃ³ downtime < 3.6 giá»/thÃ¡ng)
   - KhÃ¡ch hÃ ng cáº§n mua sáº£n pháº©m báº¥t ká»³ lÃºc nÃ o (khÃ´ng thá»ƒ downtime)
   - Äá»™ Æ°u tiÃªn: CAO (9/10)

2. **PERFORMANCE (Hiá»‡u nÄƒng)**
   - Response time < 200ms cho product listing
   - Response time < 500ms cho checkout (critical path)
   - Handle concurrent users tá»‘i thiá»ƒu 1000 concurrent
   - Äá»™ Æ°u tiÃªn: CAO (9/10)

3. **SCALABILITY (TÃ­nh má»Ÿ rá»™ng)**
   - CÃ³ thá»ƒ scale horizontally (thÃªm server) cho traffic peaks
   - Support tá»« 100 lÃªn 10,000 users/giÃ¢y trong sale event
   - Database cÃ³ thá»ƒ grow tá»« GB lÃªn TB
   - Äá»™ Æ°u tiÃªn: CAO (8/10)

4. **RELIABILITY (Äá»™ tin cáº­y)**
   - KhÃ´ng Ä‘Æ°á»£c máº¥t data (transaction failure < 0.01%)
   - Payment system pháº£i 100% reliable (no double charge)
   - Order data ACID compliant
   - Äá»™ Æ°u tiÃªn: VÃ” CÃ™NG CAO (10/10) â­

5. **SECURITY (Báº£o máº­t)**
   - Encrypt payment data (PCI DSS compliant)
   - Authentication & Authorization (JWT/OAuth)
   - Prevent SQL injection, XSS attacks
   - GDPR compliant (data privacy)
   - Äá»™ Æ°u tiÃªn: VÃ” CÃ™NG CAO (10/10) â­

6. **MODIFIABILITY (TÃ­nh dá»… sá»­a Ä‘á»•i)**
   - ThÃªm feature má»›i (promo, loyalty program) trong 2 sprint
   - Maintain vÃ  update code dá»… dÃ ng
   - Low coupling, High cohesion
   - Äá»™ Æ°u tiÃªn: TRUNG (7/10)

7. **ELASTICITY (TÃ­nh co giÃ£n)**
   - Auto-scale khi traffic tÄƒng (scale up)
   - Scale down khi traffic giáº£m (tiáº¿t kiá»‡m cost)
   - Handle traffic spike 10x trong 5 phÃºt
   - Äá»™ Æ°u tiÃªn: CAO (8/10)

8. **TESTABILITY (TÃ­nh kiá»ƒm tra Ä‘Æ°á»£c)**
   - Unit test coverage > 80%
   - Easy to mock dependencies
   - Integration test & E2E test
   - Äá»™ Æ°u tiÃªn: TRUNG (6/10)

9. **USABILITY (TÃ­nh dá»… sá»­ dá»¥ng)**
   - UI/UX responsive & intuitive
   - Mobile-first design
   - Fast checkout flow (< 3 clicks)
   - Äá»™ Æ°u tiÃªn: CAO (8/10)

10. **COST (Chi phÃ­)**
    - Infrastructure cost < 30% revenue
    - Database licensing reasonable
    - No unnecessary 3rd-party services
    - Äá»™ Æ°u tiÃªn: TRUNG (7/10)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## PHáº¦N 2: UTILITY TREE - Sáº®PXáº¾P Æ¯U TIÃŠN Äáº¶CTÃNH

ğŸ“Š UTILITY TREE (CÃ¢y tiá»‡n Ã­ch):

â”Œâ”€â”€â”€ SYSTEM GOALS
â”‚
â”œâ”€â”€â”€ CRITICAL (Pháº£i cÃ³ Ä‘á»ƒ há»‡ thá»‘ng hoáº¡t Ä‘á»™ng)
â”‚    â”œâ”€â”€ Reliability â­â­â­â­â­ (10/10)
â”‚    â”‚   â””â”€ Payment ACID compliant
â”‚    â”‚   â””â”€ Zero data loss
â”‚    â”‚   â””â”€ Transaction consistency
â”‚    â”‚
â”‚    â”œâ”€â”€ Security â­â­â­â­â­ (10/10)
â”‚    â”‚   â””â”€ Encrypt sensitive data
â”‚    â”‚   â””â”€ PCI DSS compliant
â”‚    â”‚   â””â”€ No unauthorized access
â”‚    â”‚
â”‚    â”œâ”€â”€ Availability â­â­â­â­ (9/10)
â”‚    â”‚   â””â”€ 99.5% uptime
â”‚    â”‚   â””â”€ Failover mechanism
â”‚    â”‚   â””â”€ Health check monitoring
â”‚    â”‚
â”‚    â””â”€â”€ Performance â­â­â­â­ (9/10)
â”‚        â””â”€ Response < 200ms (listing)
â”‚        â””â”€ Response < 500ms (checkout)
â”‚        â””â”€ Handle 1000 concurrent users
â”‚
â”œâ”€â”€â”€ IMPORTANT (Quan trá»ng nhÆ°ng khÃ´ng critical)
â”‚    â”œâ”€â”€ Scalability â­â­â­ (8/10)
â”‚    â”‚   â””â”€ Horizontal scale
â”‚    â”‚   â””â”€ Handle 10x traffic spike
â”‚    â”‚   â””â”€ Database sharding ready
â”‚    â”‚
â”‚    â”œâ”€â”€ Elasticity â­â­â­ (8/10)
â”‚    â”‚   â””â”€ Auto-scale infrastructure
â”‚    â”‚   â””â”€ Cost optimization
â”‚    â”‚   â””â”€ Dynamic resource allocation
â”‚    â”‚
â”‚    â”œâ”€â”€ Usability â­â­â­ (8/10)
â”‚    â”‚   â””â”€ Mobile responsive
â”‚    â”‚   â””â”€ Fast checkout
â”‚    â”‚   â””â”€ Intuitive UI
â”‚    â”‚
â”‚    â””â”€â”€ Cost â­â­ (7/10)
â”‚        â””â”€ Infrastructure cost < 30% revenue
â”‚        â””â”€ Optimize licensing
â”‚        â””â”€ Minimize 3rd-party dependencies
â”‚
â””â”€â”€â”€ NICE-TO-HAVE (CÃ³ tá»‘t, nhÆ°ng cÃ³ thá»ƒ defer)
     â”œâ”€â”€ Modifiability â­â­ (7/10)
     â”‚   â””â”€ Easy feature addition
     â”‚   â””â”€ Clean architecture
     â”‚   â””â”€ Low coupling
     â”‚
     â””â”€â”€ Testability â­â­ (6/10)
         â””â”€ Unit test coverage > 80%
         â””â”€ Mockable dependencies
         â””â”€ E2E tests

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## PHáº¦N 3: 5 QUYáº¾T Äá»ŠNH KIáº¾N TRÃšC Vá»šI TRADE-OFF ANALYSIS

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
QUYáº¾T Äá»ŠNH 1: SQL vs NoSQL DATABASE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ… CHá»ŒN: PostgreSQL (SQL Database)

TRADE-OFF ANALYSIS:

SQL (PostgreSQL)                    vs    NoSQL (MongoDB)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… PROS:                            âœ… PROS:
â€¢ ACID transactions                 â€¢ Horizontal scaling (sharding)
â€¢ Data consistency guaranteed       â€¢ Flexible schema (document-based)
â€¢ Complex JOIN queries              â€¢ High write throughput
â€¢ Foreign keys & constraints        â€¢ Good for unstructured data
â€¢ Better for relational data        â€¢ Better for real-time analytics

âŒ CONS:                            âŒ CONS:
â€¢ Vertical scaling limit            â€¢ Eventual consistency (risky for payment)
â€¢ Schema migration complex          â€¢ No ACID by default (MongoDB 4.0+ added)
â€¢ Less flexible schema              â€¢ Complex JOIN-like queries
                                    â€¢ More storage needed (denormalization)

ğŸ¯ DECISION: PostgreSQL (SQL)

JUSTIFICATION:
1. RELIABILITY (10/10) - Há»‡ thá»‘ng ecommerce cáº§n ACID transactions cho payment
   â†’ SQL Ä‘áº£m báº£o khÃ´ng cÃ³ double charge, lost transactions
   â†’ NoSQL eventual consistency khÃ´ng cháº¥p nháº­n Ä‘Æ°á»£c cho payment

2. CONSISTENCY - Order data pháº£i absolute consistent
   â†’ Payment, inventory, order status pháº£i sync
   â†’ SQL foreign keys enforce data integrity

3. COMPLEX QUERIES - Join multiple tables (orders, users, products, payments)
   â†’ SQL optimal cho relational data
   â†’ NoSQL require denormalization (data duplication, sync issues)

4. Cost - PostgreSQL open-source, MongoDB Enterprise $$

TRADE-OFF NHÃ‚N Äáº®C:
âŒ Máº¤T: KhÃ´ng scale horizontally as easily
âœ… ÄÆ¯á»¢C: ACID guarantee, data integrity, reliability

RISK & MITIGATION:
Risk: Vertical scaling limit
Mitigation: Database replication (read replicas), query optimization, cache layer (Redis)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
QUYáº¾T Äá»ŠNH 2: SYNC vs ASYNC COMMUNICATION (Product Catalog & Inventory)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ… CHá»ŒN: HYBRID - Synchronous cho critical, Asynchronous cho non-critical

ARCHITECTURE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ E-COMMERCE SYSTEM                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  CRITICAL PATH (Sync):        NON-CRITICAL (Async):             â”‚
â”‚  1. Add to cart â†’ Inventory   1. Email notification             â”‚
â”‚  2. Checkout â†’ Payment        2. Analytics tracking             â”‚
â”‚  3. Create order â†’ Database   3. Recommendation engine          â”‚
â”‚                               4. Inventory sync (warehouse)     â”‚
â”‚                               5. Audit logs                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SYNC (Synchronous)              vs    ASYNC (Asynchronous + Message Queue)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… PROS:                        âœ… PROS:
â€¢ Immediate response            â€¢ Decouple services
â€¢ Data consistency              â€¢ Better performance (fast response)
â€¢ Simple error handling         â€¢ High throughput (batch processing)
â€¢ Easier debugging              â€¢ Resilient to failures
                                â€¢ Easy to scale consumer services

âŒ CONS:                        âŒ CONS:
â€¢ Slow response (wait for all)  â€¢ Eventual consistency
â€¢ Tight coupling                â€¢ Complex error handling
â€¢ Cascading failures            â€¢ Harder to debug (distributed)
â€¢ Can't handle spikes           â€¢ Requires message queue (infra cost)
                                â€¢ Retry logic needed

ğŸ¯ DECISION: HYBRID

CRITICAL PATH (Synchronous):
â”œâ”€ Add to cart â†’ Check inventory (must be real-time)
â”œâ”€ Process payment â†’ Must succeed/fail immediately
â””â”€ Create order â†’ DB transaction (must complete atomically)

NON-CRITICAL (Asynchronous with RabbitMQ/Kafka):
â”œâ”€ Send confirmation email â†’ RabbitMQ message
â”œâ”€ Update analytics â†’ Message queue
â”œâ”€ Notify warehouse â†’ Async message
â””â”€ Generate recommendation â†’ Background job

JUSTIFICATION:
1. PERFORMANCE (9/10) - Critical path sync response < 500ms
   Async for non-critical â†’ Fast user experience
   
2. RELIABILITY (10/10) - Payment MUST be sync (no eventual consistency)
   Async for non-critical â†’ Decouple & improve resilience
   
3. SCALABILITY (8/10) - Async handles traffic spikes better
   Can scale consumers independently without blocking users

TRADE-OFF NHÃ‚N Äáº®C:
âŒ Máº¤T: Operational complexity (need RabbitMQ), eventual consistency on non-critical
âœ… ÄÆ¯á»¢C: Fast response + resilient + decoupled

IMPLEMENTATION:
Message Queue: RabbitMQ
â”œâ”€ Queue: "order.created" â†’ Email service
â”œâ”€ Queue: "payment.success" â†’ Analytics service
â”œâ”€ Queue: "inventory.updated" â†’ Warehouse service
â””â”€ Dead Letter Queue: Retry mechanism

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
QUYáº¾T Äá»ŠNH 3: MONOLITHIC vs MICROSERVICES ARCHITECTURE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ… CHá»ŒN: MODULAR MONOLITH (Best of both worlds)

ARCHITECTURE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         SINGLE DEPLOYABLE UNIT (Monolith)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚  User Service   â”‚  â”‚ Product Service  â”‚             â”‚
â”‚  â”‚  - Register     â”‚  â”‚ - Catalog        â”‚             â”‚
â”‚  â”‚  - Login        â”‚  â”‚ - Search         â”‚             â”‚
â”‚  â”‚  - Profile      â”‚  â”‚ - Reviews        â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ Order Service   â”‚  â”‚ Payment Service  â”‚             â”‚
â”‚  â”‚ - Cart          â”‚  â”‚ - Process        â”‚             â”‚
â”‚  â”‚ - Checkout      â”‚  â”‚ - Verify         â”‚             â”‚
â”‚  â”‚ - History       â”‚  â”‚ - Refund         â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚        SHARED DATABASE (PostgreSQL)      â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚    MESSAGE QUEUE (RabbitMQ) - Optional   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Monolith                        vs    Microservices
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… PROS:                        âœ… PROS:
â€¢ Simple deployment             â€¢ Independent scaling
â€¢ Easy debugging                â€¢ Technology flexibility
â€¢ Good performance (no network) â€¢ Team autonomy
â€¢ ACID transactions easy        â€¢ Deploy without downtime
â€¢ Shared DB consistency         â€¢ Easier to replace parts

âŒ CONS:                        âŒ CONS:
â€¢ Single point of failure       â€¢ Network latency
â€¢ Can't scale individual parts  â€¢ Distributed transaction nightmare
â€¢ Tech stack lock-in            â€¢ Operational complexity
â€¢ Long deployment cycle         â€¢ Data consistency issues
â€¢ Testing is slower             â€¢ Testing distributed system hard
                                â€¢ 3x infrastructure cost

ğŸ¯ DECISION: MODULAR MONOLITH

JUSTIFICATION:
1. SIMPLICITY - Dá»… develop, deploy, maintain cho team nhá» (Junior developer)
   KhÃ´ng cáº§n setup Kubernetes, service mesh, distributed tracing
   
2. RELIABILITY (10/10) - Single database â†’ ACID transactions guaranteed
   Avoid distributed transaction complexity (2-phase commit hell)
   
3. PERFORMANCE (9/10) - No network latency between services
   In-process communication vs RPC calls
   
4. COST - Single deployment, single database, less infrastructure
   
5. FUTURE-PROOF - Can evolve to microservices later (modular design enables this)

TRADE-OFF NHÃ‚N Äáº®C:
âŒ Máº¤T: Can't scale individual services, potential bottleneck
âœ… ÄÆ¯á»¢C: Simple, reliable, fast, easy to maintain

MIGRATION PATH:
Phase 1 (Now): Modular Monolith
Phase 2 (6 months): Extract to Microservices if needed
Phase 3 (Scale): Full microservices architecture

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
QUYáº¾T Äá»ŠNH 4: CACHING STRATEGY - Where & How
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ… CHá»ŒN: MULTI-LAYER CACHING STRATEGY

CACHING ARCHITECTURE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      CLIENT (Browser)                           â”‚
â”‚                  HTTP Cache (Expires header)                    â”‚
â”‚                  Max-Age: 5 minutes (static assets)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    API GATEWAY / CDN                            â”‚
â”‚                  Response cache (Cloudflare)                    â”‚
â”‚                  Cache product listings (1 hour)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  APPLICATION LAYER (Node.js)                    â”‚
â”‚                     Redis Cache                                 â”‚
â”‚   â”œâ”€ Product cache (TTL: 1 hour)                              â”‚
â”‚   â”œâ”€ Category cache (TTL: 2 hours)                            â”‚
â”‚   â”œâ”€ User session (TTL: 24 hours)                             â”‚
â”‚   â”œâ”€ Cart (TTL: 7 days, persistent)                           â”‚
â”‚   â””â”€ Search results (TTL: 30 minutes)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   DATABASE (PostgreSQL)                         â”‚
â”‚                  Source of Truth                                â”‚
â”‚                  Persistent Storage                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CACHE INVALIDATION STRATEGY:
1. TTL-based (Time-To-Live) - Auto expire after time
   â””â”€ For product listing, category

2. Event-based - Invalidate on change
   â””â”€ When product updated â†’ Clear cache
   â””â”€ When inventory changed â†’ Clear product cache
   â””â”€ When user profile changed â†’ Clear user cache

3. Lazy Loading - Invalidate when accessed
   â””â”€ Check DB, if changed â†’ Update cache

Cache-Aside Pattern (Most Common):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Request for product ID 123               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Check Redis cache                     â”‚
â”‚    â”œâ”€ FOUND? â†’ Return cached data (FAST)â”‚
â”‚    â””â”€ NOT FOUND? â†’ Go to DB              â”‚
â”‚ 2. Query PostgreSQL                      â”‚
â”‚ 3. Update Redis cache (TTL: 1 hour)      â”‚
â”‚ 4. Return to client                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WITH CACHING             vs    WITHOUT CACHING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… PROS:                 âœ… PROS:
â€¢ Fast response (< 50ms) â€¢ Simple (no cache layer)
â€¢ Reduce DB load         â€¢ Always fresh data
â€¢ Handle more users      â€¢ No cache invalidation issues
â€¢ Better UX              â€¢ Less infrastructure

âŒ CONS:                 âŒ CONS:
â€¢ Stale data risk        â€¢ Slow response (> 200ms)
â€¢ Cache invalidation     â€¢ DB bottleneck
â€¢ Complexity             â€¢ Can't handle traffic spikes
â€¢ Extra infrastructure   â€¢ Poor UX

ğŸ¯ DECISION: MULTI-LAYER CACHING

JUSTIFICATION:
1. PERFORMANCE (9/10) - Product listing response < 50ms (from Redis)
   Without cache â†’ 200ms (DB query) â†’ fails requirement
   
2. SCALABILITY (8/10) - Handle 1000 concurrent users
   Cache reduce DB load by 80-90%
   
3. COST - Less DB connections needed = less expensive
   
4. AVAILABILITY (9/10) - If DB slow, cache serve stale data
   Better than timing out

TRADE-OFF NHÃ‚N Äáº®C:
âŒ Máº¤T: Stale data (products might be wrong for 1 hour), cache invalidation complexity
âœ… ÄÆ¯á»¢C: Fast response, scalable, handle spikes

CACHE INVALIDATION STRATEGY:
When product updated:
â”œâ”€ DELETE cache key "product:123"
â”œâ”€ DELETE cache key "category:electronics" (if related)
â”œâ”€ Publish "product.updated" event to message queue
â””â”€ Invalidate CDN cache

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
QUYáº¾T Äá»ŠNH 5: PAYMENT PROCESSING - 3RD PARTY vs IN-HOUSE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ… CHá»ŒN: 3RD PARTY PAYMENT GATEWAY (Stripe/PayPal)

ARCHITECTURE:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              PAYMENT FLOW (3RD PARTY)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                            â”‚
â”‚  1. User fills card info                                  â”‚
â”‚  2. Call Stripe API (never see card details)             â”‚
â”‚  3. Stripe processes payment                             â”‚
â”‚  4. Stripe webhook callback to our server                â”‚
â”‚  5. Our server updates order status                       â”‚
â”‚  6. User redirected to success page                       â”‚
â”‚                                                            â”‚
â”‚  âœ… PCI DSS compliance handled by Stripe                 â”‚
â”‚  âœ… Encryption & security included                       â”‚
â”‚  âœ… 99.99% uptime SLA                                    â”‚
â”‚  âœ… Fraud detection built-in                             â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3RD PARTY (Stripe)           vs    IN-HOUSE PAYMENT SYSTEM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… PROS:                     âœ… PROS:
â€¢ PCI DSS compliance         â€¢ Full control
â€¢ 99.99% uptime              â€¢ No 3rd party dependency
â€¢ Fraud detection            â€¢ Custom logic
â€¢ Multiple payment methods   â€¢ Save on payment fees
â€¢ Tokenization               â€¢ No integration complexity
â€¢ Webhook handling           â€¢ Direct data access
â€¢ 24/7 support

âŒ CONS:                     âŒ CONS:
â€¢ 2.9% + $0.30 per txn fee  â€¢ PCI DSS cert required ($$, complex)
â€¢ Dependency on 3rd party    â€¢ Security responsibility (high risk)
â€¢ API rate limits            â€¢ Maintain & update constantly
â€¢ Less control               â€¢ Fraud detection needed
                             â€¢ Build redundancy (failover)
                             â€¢ 24/7 monitoring required
                             â€¢ Hire security experts ($$$)

ğŸ¯ DECISION: 3RD PARTY PAYMENT GATEWAY (Stripe)

JUSTIFICATION:
1. SECURITY (10/10) - Payment processing is HIGH RISK
   âŒ In-house = PCI DSS violation = $5000-$100,000 fine per incident
   âœ… Stripe = PCI DSS compliant, handles all security
   
2. RELIABILITY (10/10) - Stripe SLA: 99.99% uptime
   âŒ In-house = Single point of failure = lost revenue
   âœ… Stripe = Global redundancy, automatic failover
   
3. COST - Stripe 2.9% fee vs hiring 1 security engineer ($100K/year)
   Payment fees = $290 per $10K transactions
   Security engineer = $100K/year for 1 person
   Cost-benefit: Pay fees is cheaper
   
4. TIME-TO-MARKET - Can integrate Stripe in 1 day
   In-house payment system = 3 months development + security audit
   
5. COMPLIANCE - Stripe handles PCI DSS, GDPR, etc.

TRADE-OFF NHÃ‚N Äáº®C:
âŒ Máº¤T: 2.9% transaction fee, dependency on Stripe, less control
âœ… ÄÆ¯á»¢C: Security, compliance, reliability, fast time-to-market

IMPLEMENTATION:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stripe Integration                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Client â†’ Stripe (card info)                         â”‚
â”‚ 2. Stripe â†’ Payment intent                             â”‚
â”‚ 3. Confirm payment                                      â”‚
â”‚ 4. Stripe â†’ Webhook                                     â”‚
â”‚ 5. Update DB order status                               â”‚
â”‚ 6. Send confirmation email                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Fallback: If Stripe down (rare):
â”œâ”€ Store pending orders in queue
â”œâ”€ Retry every 5 minutes
â”œâ”€ Notify admin
â””â”€ Manual processing if needed

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## PHáº¦N 4: ARCHITECTURAL DECISION RECORD (ADR)

ADR lÃ  document ghi láº¡i cÃ¡c quyáº¿t Ä‘á»‹nh kiáº¿n trÃºc, why, trade-offs.

### ADR-1: Database Selection (SQL vs NoSQL)

Title: Use PostgreSQL as Primary Database

Status: ACCEPTED

Context:
E-commerce systems require strong consistency, especially for payment processing.
We evaluated SQL (PostgreSQL) and NoSQL (MongoDB).

Decision:
Use PostgreSQL as primary database.

Rationale:
1. ACID transactions guarantee payment consistency
2. Foreign keys ensure data integrity
3. Complex queries across multiple entities
4. Simpler to maintain than NoSQL for relational data
5. Open-source (no licensing cost)

Consequences:
âœ… Guaranteed ACID consistency
âœ… Strong data integrity
âŒ Limited horizontal scaling (need read replicas)
âŒ Vertical scaling limit

Alternatives Considered:
- MongoDB: Considered, rejected due to eventual consistency risk for payments

Migration Path:
- Phase 1: PostgreSQL monolith
- Phase 2: Add read replicas if needed
- Phase 3: Database sharding for large scale

---

### ADR-2: Synchronous vs Asynchronous Communication

Title: Use Hybrid Approach (Sync for Critical, Async for Non-Critical)

Status: ACCEPTED

Context:
High-volume ecommerce system needs both speed and reliability.
Critical operations (payment, orders) need immediate response.
Non-critical operations (email, analytics) can be asynchronous.

Decision:
- Synchronous: Add-to-cart, Checkout, Payment, Create Order
- Asynchronous: Email notifications, Analytics, Recommendations

Rationale:
1. Critical path must be sync (ACID guarantee)
2. Non-critical can be async (improve performance)
3. Decouple services reduces cascading failures
4. Handle traffic spikes better with async
5. Better user experience (faster response)

Consequences:
âœ… Fast response time (< 200ms)
âœ… High throughput for non-critical
âœ… Better resilience (decouple services)
âŒ Eventual consistency on non-critical
âŒ Need message queue infrastructure
âŒ Harder to debug distributed issues

Implementation:
- Message Queue: RabbitMQ
- Dead Letter Queue: Retry 3x then alert

---

### ADR-3: Monolithic vs Microservices

Title: Use Modular Monolith Architecture

Status: ACCEPTED

Context:
Small team (5 developers), need fast development cycle.
Microservices add operational complexity (Docker, Kubernetes, etc.).
Modular monolith allows future migration to microservices.

Decision:
Deploy as single monolithic application with modular service structure.

Rationale:
1. Simple deployment (1 container, 1 database)
2. Easy ACID transactions (single DB)
3. No network latency between services
4. Easier debugging (single process)
5. Can migrate to microservices later if needed
6. Good for team size and maturity

Consequences:
âœ… Simple deployment and operations
âœ… ACID transactions guaranteed
âœ… Good performance (no RPC)
âŒ Can't scale individual services
âŒ Tech stack lock-in
âŒ May hit limits at extreme scale

Migration Path:
- Phase 1: Modular Monolith (now)
- Phase 2: Extract Payment Service (high value, isolated)
- Phase 3: Extract Order Service
- Phase 4: Full microservices (if needed)

---

### ADR-4: Caching Strategy

Title: Implement Multi-Layer Caching

Status: ACCEPTED

Context:
Database query performance is bottleneck for product listing (200ms vs 50ms target).
Need to handle 1000 concurrent users.

Decision:
Implement 3-layer caching:
1. Browser cache (HTTP headers)
2. Redis cache (in-memory)
3. Database (source of truth)

Rationale:
1. Dramatically improve response time
2. Reduce database load (80-90%)
3. Handle more concurrent users
4. Cost-effective (one Redis instance)
5. Standard industry practice

Consequences:
âœ… Response time < 50ms (from cache)
âœ… Handle 10x more users
âœ… Lower infrastructure cost
âŒ Data might be stale (1 hour old)
âŒ Cache invalidation complexity
âŒ Need to understand TTL & invalidation

Cache Invalidation:
- TTL: Auto-expire (1 hour for products)
- Event-based: Clear on product update
- Manual: Cache.delete() when needed

---

### ADR-5: Payment Processing

Title: Use Stripe as Payment Gateway (3rd Party)

Status: ACCEPTED

Context:
Payment processing is high-risk (security, compliance, reliability).
Options: Build in-house vs use Stripe/PayPal.

Decision:
Use Stripe as primary payment gateway.

Rationale:
1. PCI DSS compliance handled by Stripe
2. 99.99% uptime SLA
3. Fraud detection built-in
4. Security expertise expensive (in-house)
5. Fast integration (1 day vs 3 months)
6. Multiple payment methods (card, Apple Pay, etc.)

Consequences:
âœ… Security & compliance guaranteed
âœ… High reliability (99.99% uptime)
âœ… Fast time-to-market
âŒ 2.9% + $0.30 transaction fee
âŒ Dependency on 3rd party
âŒ Less control over payment flow

Cost Analysis:
- Stripe fee: 2.9% on $100K revenue = $2,900/month
- Security engineer salary: $100K/year = $8,333/month
- Result: Stripe is cheaper, more secure

Fallback:
- If Stripe unavailable (rare): Queue orders, retry every 5 minutes
- Manual processing for critical orders

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## PHáº¦N 5: Tá»”NG Káº¾T TRADE-OFFS

1. SQL vs NoSQL:
   âŒ Lost: Horizontal scaling    âœ… Gained: ACID guarantee, strong consistency

2. Sync vs Async:
   âŒ Lost: Simplicity             âœ… Gained: Performance, scalability, resilience

3. Monolith vs Microservices:
   âŒ Lost: Service independence   âœ… Gained: Simplicity, performance, reliability

4. With vs Without Caching:
   âŒ Lost: Data freshness         âœ… Gained: 10x faster response, scalability

5. 3rd Party vs In-House Payment:
   âŒ Lost: 2.9% fee              âœ… Gained: Security, compliance, reliability

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ARCHITECTURAL THINKING KEY POINTS:

1. "Best Practice" khÃ´ng tá»“n táº¡i â†’ Chá»‰ cÃ³ "Best for this context"
2. Má»—i quyáº¿t Ä‘á»‹nh cÃ³ trade-off
3. Pháº£i hiá»ƒu cÃ¡i mÃ¬nh nhÃ¢n Ä‘áº¯c vÃ  cÃ¡i mÃ¬nh máº¥t
4. Trade-off dá»±a trÃªn business goals & constraints
5. Document láº¡i quyáº¿t Ä‘á»‹nh (ADR) cho team sau hiá»ƒu

DECISION MAKING FRAMEWORK:

Step 1: XÃ¡c Ä‘á»‹nh priorities (reliability > performance > scalability)
Step 2: List options (SQL/NoSQL, Sync/Async, etc)
Step 3: Analyze trade-off tá»«ng option
Step 4: Choose dá»±a trÃªn priorities
Step 5: Document trong ADR
Step 6: Review & iterate khi context thay Ä‘á»•i

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
